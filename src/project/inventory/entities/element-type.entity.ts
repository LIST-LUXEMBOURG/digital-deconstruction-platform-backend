/*
 *   Copyright (c) 2022 Luxembourg Institute of Science and Technology
 *   All rights reserved.
 *   For licensing information see the "LICENSE" file in the root directory
 */
import {
    Entity,
    Column,
    OneToMany,
    PrimaryGeneratedColumn,
    Unique,
    ManyToMany,
    JoinTable,
    ManyToOne,
    JoinColumn,
    OneToOne,
} from 'typeorm';
import { ClassificationEntry } from '../../../core/entities/classification-entry.entity';
import { InventoryFile } from './inventory-file.entity';
import { Project } from '../../../project/entities';
import { InventoryElementTypeDto } from '../dto/inventory-element-type.dto';
import { Circularity } from '../../../circularity/entities/circularity.entity';

@Entity()
@Unique('unique_element_type_name_project', ['name', 'project'])
@Unique('unique_element_type_ifcid_project', ['ifcId', 'project'])
export class ElementType {
    @PrimaryGeneratedColumn('uuid')
    uid: string; // string | generated by platform | automatic | ignored

    @ManyToOne(
        (type) => Project,
        {
            onDelete: "CASCADE",
        }
    )
    @JoinColumn()
    project: Project;

    @Column({ type: String, nullable: true })
    ifcId: string;

    @Column({ type: String, nullable: true })
    ifcType: string;

    @Column({ type: String, nullable: false })
    name: string;

    @Column({ type: String, nullable: true })
    description: string;

    @Column({ type: String, nullable: true })
    category: string;

    @Column({ type: String, nullable: true })
    historicalValue: string;

    @Column({ type: String, nullable: true })
    trademark: string;

    @Column({ type: String, nullable: true })
    designer: string;

    @ManyToMany(() => ClassificationEntry, (classification) => classification.elementTypes, {
        cascade: true,
        onUpdate: 'CASCADE',
    })
    @JoinTable({ name: "element_type_classification_entry_rel" })
    classificationEntries: ClassificationEntry[];

    @OneToMany(() => InventoryFile, (file) => file.elementType, {
        cascade: true,
        onUpdate: 'CASCADE',
    })
    files: InventoryFile[];

    @OneToOne(() => Circularity, (circ) => circ.elementType, {
        cascade: true,
        onDelete: 'SET NULL',
        onUpdate: 'CASCADE',
    })
    circularity: Circularity;

    //----------------------------------------------------------------------- 

    static toDto(elementType: ElementType): InventoryElementTypeDto {
        let dto = new InventoryElementTypeDto();

        if (!!elementType) {
            let { project, classificationEntries, files, circularity, ...fields } = elementType;

            dto = Object.assign(dto, { ...fields });

            if (!!project) {
                dto.projectId = project.id;
            }

            if (!!classificationEntries) {
                dto.classificationEntries = classificationEntries.map(entry => ClassificationEntry.toDto(entry));
            }

            if (!!files) {
                dto.files = files.map(file => InventoryFile.toDto(file));
            }

            if (!!circularity) {
                dto.circularity = Circularity.toDto(circularity);
            }
        }
        return dto;
    }
}